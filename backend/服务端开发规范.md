# 🌟服务端 MVC 开发规范

## 1. 架构设计规范

### 1.1 MVC 分层架构

```
src/
├── controllers/           // 控制器层
├── services/             // 服务层
├── models/              // 模型层
├── repositories/        // 数据访问层
├── middlewares/         // 中间件层
├── routers/             // 路由层
├── types/               // 类型定义
├── enums/               // 枚举定义
├── utils/               // 工具函数
├── config/              // 配置管理
└── validators/          // 验证器
```

### 1.2 依赖流向原则
```
Controller → Service → Repository → Model
     ↓
Middleware → Validator → Utils
```

## 2. 文件命名规范

### 2.1 目录命名
- 使用**复数形式** + **小写短横线**
```typescript
users/
user-profiles/
order-items/
```

### 2.2 文件命名
- **控制器**: `复数名词 + 控制器类型`
```typescript
users-controller.ts
user-profiles-controller.ts
```

- **服务**: `复数名词 + 服务类型`  
```typescript
users-service.ts
orders-service.ts
```

- **模型**: `单数名词 + 模型类型`
```typescript
user-model.ts
order-model.ts
```

- **类型定义**: `领域名词 + 类型`
```typescript
user-types.ts
order-types.ts
```

## 3. 代码元素命名规范

### 3.1 接口命名 (前缀 I)
```typescript
// 实体接口
interface IUser {
  id: string;
  name: string;
  email: string;
}

// 服务接口
interface IUserService {
  createUser(userData: TCreateUserData): Promise<TUserResponse>;
  getUserById(id: string): Promise<TUserDetails>;
}

// 仓库接口
interface IUserRepository {
  findById(id: string): Promise<IUser | null>;
  save(user: IUser): Promise<IUser>;
}
```

### 3.2 类型别名命名 (前缀 T)
```typescript
// 请求数据类型
type TCreateUserRequest = {
  name: string;
  email: string;
  password: string;
};

// 响应数据类型
type TUserResponse = {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
};

// 查询参数类型
type TUserQueryParams = {
  page?: number;
  limit?: number;
  search?: string;
  sortBy?: string;
};
```

### 3.3 枚举命名 (前缀 N)
```typescript
// 状态枚举
enum NUserStatus {
  Active = 'active',
  Inactive = 'inactive',
  Suspended = 'suspended'
}

// 角色枚举
enum NUserRole {
  Admin = 'admin',
  User = 'user',
  Moderator = 'moderator'
}

// 错误码枚举
enum NErrorCode {
  NotFound = 404,
  ValidationError = 422,
  InternalError = 500
}
```

### 3.4 类命名
```typescript
// 控制器类
class UsersController {
  // 使用卫语句提前返回
  async createUser(request: TCreateUserRequest): Promise<TUserResponse> {
    // 参数验证
    if (!this.isValidUserData(request)) {
      throw new Error('Invalid user data');
    }
    
    // 业务逻辑委托给服务层
    return await this.userService.createUser(request);
  }
}

// 服务类
class UserService implements IUserService {
  // 使用对象映射替代条件分支
  private readonly ROLE_PERMISSIONS = {
    [NUserRole.Admin]: ['read', 'write', 'delete'],
    [NUserRole.User]: ['read'],
    [NUserRole.Moderator]: ['read', 'write']
  };

  async getUserPermissions(role: NUserRole): string[] {
    return this.ROLE_PERMISSIONS[role] ?? [];
  }
}

// 模型类
class UserModel implements IUser {
  constructor(
    public id: string,
    public name: string,
    public email: string,
    public status: NUserStatus = NUserStatus.Active
  ) {}
}
```

### 3.5 函数与方法命名
```typescript
// 使用动词+名词形式，清晰表达意图
class OrderService {
  // 数据查询
  async findOrdersByUserId(userId: string): Promise<TOrder[]> {
    return this.orderRepository.findByUserId(userId);
  }

  // 数据创建
  async createOrderFromCart(cartData: TCartData): Promise<TOrder> {
    // 使用可选链简化对象访问
    const totalAmount = cartData.items?.reduce((sum, item) => 
      sum + (item.price ?? 0) * (item.quantity ?? 0), 0
    ) ?? 0;

    return this.orderRepository.create({ ...cartData, totalAmount });
  }

  // 状态更新
  async updateOrderStatus(orderId: string, status: NOrderStatus): Promise<boolean> {
    const result = await this.orderRepository.updateStatus(orderId, status);
    return result.affectedRows > 0;
  }
}
```

### 3.6 变量命名
```typescript
// 使用有意义的名称，避免缩写
class ProductController {
  async getProductsWithInventory() {
    // 使用描述性变量名
    const availableProducts = await this.productService
      .findAll()
      .then(products => products
        .map(product => ({
          ...product,
          // 使用可选链和空值合并
          inStock: (product.inventory?.quantity ?? 0) > 0
        }))
        .filter(product => product.inStock)
      );

    return availableProducts;
  }
}
```

## 4. 代码组织规范

### 4.1 导入导出规范
```typescript
// 类型导入（分组清晰）
import { 
  IUserService, 
  IUserRepository 
} from '../interfaces/';
import { 
  TUserResponse, 
  TCreateUserRequest 
} from '../types/user-types';
import { 
  NUserStatus, 
  NUserRole 
} from '../enums/user-enums';

// 工具函数导入
import { 
  validateEmail, 
  generateHash 
} from '../../utils/validation-utils';

// 默认导出（用于主要组件）
export default class UserController {
  // ...
}

// 命名导出（用于工具函数、类型等）
export { TUserResponse, TCreateUserRequest };
export { USER_VALIDATION_RULES } from './validation-rules';
```

### 4.2 异步处理规范
```typescript
class ApiService {
  // 使用 Promise.all 进行并行操作
  async getUserDashboard(userId: string): Promise<TDashboard> {
    try {
      const [user, orders, notifications] = await Promise.all([
        this.userService.findUserById(userId),
        this.orderService.findOrdersByUserId(userId),
        this.notificationService.getUserNotifications(userId)
      ]);

      // 使用卫语句处理边界情况
      if (!user) {
        throw new Error('User not found');
      }

      return { user, orders, notifications };
    } catch (error) {
      // 精细错误处理
      if (error instanceof NetworkError) {
        this.logger.error('Network error in dashboard service', error);
        throw new Error('Service temporarily unavailable');
      }
      throw error;
    } finally {
      // 使用 finally 进行清理
      this.cleanupDashboardRequest(userId);
    }
  }

  // 大量数据分批处理
  async processBulkUsers(userIds: string[]): Promise<TProcessResult[]> {
    const batchSize = 50;
    const batches = [];

    for (let i = 0; i < userIds.length; i += batchSize) {
      const batch = userIds.slice(i, i + batchSize);
      batches.push(
        Promise.allSettled(
          batch.map(userId => this.processSingleUser(userId))
        )
      );
    }

    const results = await Promise.all(batches);
    return results.flat();
  }
}
```

## 5. 设计原则应用

### 5.1 SOLID 原则实现
```typescript
// 单一职责原则
class UserValidationService {
  // 只负责用户数据验证
  validateUserData(userData: TCreateUserRequest): TValidationResult {
    const errors: string[] = [];
    
    // 使用卫语句提前返回
    if (!userData.email?.includes('@')) {
      errors.push('Invalid email format');
    }
    
    if ((userData.password?.length ?? 0) < 8) {
      errors.push('Password must be at least 8 characters');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// 开闭原则 - 对扩展开放，对修改关闭
abstract class NotificationService {
  abstract send(message: string): Promise<boolean>;
}

class EmailNotificationService extends NotificationService {
  async send(message: string): Promise<boolean> {
    // 邮件发送实现
    return true;
  }
}

class SmsNotificationService extends NotificationService {
  async send(message: string): Promise<boolean> {
    // 短信发送实现
    return true;
  }
}
```

### 5.2 DRY 原则 - 工具函数抽象
```typescript
// utils/response-utils.ts
export const buildSuccessResponse = <T>(
  data: T, 
  message: string = 'Success'
): TApiResponse<T> => ({
  success: true,
  data,
  message,
  timestamp: new Date()
});

export const buildErrorResponse = (
  error: string, 
  code: NErrorCode = NErrorCode.InternalError
): TApiResponse<null> => ({
  success: false,
  data: null,
  error,
  code,
  timestamp: new Date()
});
```

## 6. 质量保证规范

### 6.1 代码提交检查清单
- ✅ 接口命名以 `I` 前缀开头
- ✅ 类型别名以 `T` 前缀开头  
- ✅ 枚举以 `N` 前缀开头
- ✅ 文件使用复数形式命名
- ✅ 条件逻辑嵌套不超过 2 层
- ✅ 多分支场景使用对象映射/Map
- ✅ 链式取值使用可选链 `?.`
- ✅ 涉及 `this` 的函数未使用箭头函数
- ✅ 异步操作正确使用 Promise 组合方法
- ✅ 大量任务采用批处理/池化技术
- ✅ 错误处理包含 `finally` 保底操作
- ✅ 顺序执行使用 `for...of + await`

## 7. Commit 信息规范

为保证代码提交历史清晰可追溯，便于协同开发和版本管理，推荐采用 **Conventional Commits 规范** 作为 commit message 的格式标准。


### 7.1 基本格式
commit message 需遵循以下结构：
```
<类型>[可选作用域]: <描述>

[可选正文]

[可选脚注]
```


### 7.2 各部分说明

#### 7.2.1 类型（Type）
用于说明 commit 的性质，必须为以下值之一：
- `feat`：新增功能（如新增 API 接口、新增服务方法）
- `fix`：修复 bug（如修复控制器逻辑错误、修复服务层异常处理）
- `docs`：文档变更（如更新开发规范、补充接口注释）
- `style`：代码格式调整（不影响代码逻辑，如缩进、变量命名格式修正）
- `refactor`：代码重构（既非新增功能也非修复 bug，如优化服务层算法、调整控制器参数校验逻辑）
- `perf`：性能优化（如提升数据库查询效率、减少接口响应时间）
- `test`：新增或修改测试代码（如为服务层添加单元测试、补充控制器集成测试）
- `build`：构建配置变更（如修改打包配置、依赖版本更新）
- `ci`：持续集成配置变更（如调整 GitHub Actions 工作流、修改 Jenkins 脚本）
- `chore`：其他不影响代码逻辑的变更（如删除冗余文件、调整目录结构）


#### 7.2.2 作用域（Scope）
可选，用于指定 commit 影响的模块，建议与项目目录结构对应，例如：
- `controllers`：控制器层
- `services`：服务层
- `models`：模型层
- `repositories`：数据访问层
- `routers`：路由层
- `types`：类型定义
- `enums`：枚举定义
- `utils`：工具函数
- `config`：配置文件


#### 7.2.3 描述（Description）
- 简洁描述 commit 的核心内容（不超过 50 字符）
- 使用现在时（如“add”而非“added”）
- 首字母小写，结尾不加句号


#### 7.2.4 正文（Body）
可选，详细说明 commit 的背景、修改原因和具体内容，可换行。


#### 7.2.5 脚注（Footer）
可选，用于标记破坏性变更或关闭 issues：
- 破坏性变更：以 `BREAKING CHANGE:` 开头，说明变更内容及迁移方法
- 关闭 issues：使用 `Closes #123` 或 `Fixes #456` 格式关联 issue 编号


### 7.3 示例
```
feat(controllers): add user profile update API

- 新增 PATCH /users/:id/profile 接口
- 支持更新用户昵称、头像等非敏感信息
- 依赖 user-service 的 updateProfile 方法

Closes #789
```

```
fix(services): fix order status update logic in OrderService

修复订单状态更新时未校验权限的问题，现在会先通过 UserService 验证操作人角色

BREAKING CHANGE: OrderService.updateStatus 方法不再接受 rawStatus 参数，需传入 NOrderStatus 枚举值
```

```
refactor(models): simplify UserModel constructor

移除冗余的默认值设置，改用参数默认值简化代码
```


### 7.4 协同开发约束工具
为确保团队成员遵守 commit 规范，推荐配置 **commitlint** 进行自动检查：

#### 7.4.1 安装依赖
```bash
npm install --save-dev @commitlint/cli @commitlint/config-conventional husky
```

#### 7.4.2 配置 commitlint
创建 `commitlint.config.js` 文件：
```javascript
module.exports = {
  extends: ['@commitlint/config-conventional']
};
```

#### 7.4.3 配置 husky 钩子
在 `package.json` 中添加：
```json
{
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  }
}
```

#### 7.4.4 生效配置
```bash
npx husky install
npx husky add .husky/commit-msg 'npx --no -- commitlint --edit $1'
```

配置完成后，不符合规范的 commit 会被拦截，确保提交历史的一致性。